From 6e4f89c19abd686802c6660184573a3855168b63 Mon Sep 17 00:00:00 2001
From: Roger Zanoni <rzanoni@igalia.com>
Date: Wed, 17 May 2023 21:25:53 +0200
Subject: [PATCH 6/8] Add webos/agl waylandwindow/window tree host essential
 parts

---
 ui/aura/BUILD.gn                              |  7 ++
 ui/aura/agl/window_tree_host_agl.h            | 42 +++++++++
 ui/aura/agl/window_tree_host_platform_agl.cc  | 50 +++++++++++
 ui/aura/agl/window_tree_host_platform_agl.h   | 51 +++++++++++
 ui/aura/window_tree_host.h                    |  5 +-
 ui/aura/window_tree_host_platform.cc          |  4 +-
 ui/aura/window_tree_host_platform.h           |  4 +-
 ui/ozone/platform/wayland/BUILD.gn            |  1 -
 .../platform/wayland/extensions/agl/BUILD.gn  |  2 +
 .../agl/host/wayland_extensions_agl.h         | 10 ++-
 .../agl/host/wayland_extensions_agl_impl.cc   | 11 ++-
 .../agl/host/wayland_extensions_agl_impl.h    |  9 ++
 .../extensions/agl/host/wayland_window_agl.cc | 86 +++++++++++++++++++
 .../extensions/agl/host/wayland_window_agl.h  | 49 +++++++++++
 .../wayland/gpu/gl_surface_wayland.cc         | 14 ++-
 .../host/gtk_primary_selection_device.cc      |  2 +-
 .../gtk_primary_selection_device_manager.cc   |  4 +-
 .../wayland/host/proxy/wayland_proxy_impl.cc  |  2 +-
 .../wayland/host/wayland_connection.cc        | 23 ++++-
 .../wayland/host/wayland_connection.h         |  9 +-
 .../platform/wayland/host/wayland_cursor.cc   |  4 +-
 .../wayland/host/wayland_data_device.cc       | 10 +--
 .../wayland/host/wayland_data_device_base.cc  |  2 +-
 .../host/wayland_data_drag_controller.cc      |  2 +-
 .../wayland/host/wayland_data_source.cc       |  6 +-
 ui/ozone/platform/wayland/host/wayland_drm.cc |  6 +-
 .../wayland/host/wayland_extensions.h         |  6 ++
 .../platform/wayland/host/wayland_keyboard.cc |  4 +-
 .../platform/wayland/host/wayland_popup.cc    |  4 +-
 ui/ozone/platform/wayland/host/wayland_shm.cc |  2 +-
 .../platform/wayland/host/wayland_surface.cc  |  2 +-
 .../wayland/host/wayland_toplevel_window.cc   | 14 +--
 .../platform/wayland/host/wayland_window.cc   | 14 +--
 .../platform/wayland/host/wayland_window.h    |  2 +
 .../host/wayland_window_drag_controller.cc    |  2 +-
 .../wayland/host/wayland_window_factory.cc    | 15 ++++
 .../wayland/host/wayland_zwp_linux_dmabuf.cc  |  4 +-
 .../wayland/host/xdg_foreign_wrapper.cc       |  4 +-
 .../wayland/host/xdg_popup_wrapper_impl.cc    |  2 +-
 .../wayland/host/xdg_surface_wrapper_impl.cc  |  2 +-
 .../host/zwp_primary_selection_device.cc      |  2 +-
 .../zwp_primary_selection_device_manager.cc   |  4 +-
 .../host/zxdg_surface_v6_wrapper_impl.cc      |  2 +-
 ui/platform_window/agl/platform_window_agl.h  | 36 ++++++++
 ui/platform_window/platform_window.h          |  4 +-
 45 files changed, 473 insertions(+), 67 deletions(-)
 create mode 100644 ui/aura/agl/window_tree_host_agl.h
 create mode 100644 ui/aura/agl/window_tree_host_platform_agl.cc
 create mode 100644 ui/aura/agl/window_tree_host_platform_agl.h
 create mode 100644 ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc
 create mode 100644 ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h
 create mode 100644 ui/platform_window/agl/platform_window_agl.h

diff --git a/ui/aura/BUILD.gn b/ui/aura/BUILD.gn
index 1beb9003b2fad..f3d3e359a9704 100644
--- a/ui/aura/BUILD.gn
+++ b/ui/aura/BUILD.gn
@@ -99,6 +99,13 @@ component("aura") {
     "window_tree_host_platform.cc",
   ]
 
+  public += [
+    "agl/window_tree_host_agl.h",
+    "agl/window_tree_host_platform_agl.h"
+  ]
+
+  sources += [ "agl/window_tree_host_platform_agl.cc" ]
+
   friend = [ ":*" ]
 
   defines = [ "AURA_IMPLEMENTATION" ]
diff --git a/ui/aura/agl/window_tree_host_agl.h b/ui/aura/agl/window_tree_host_agl.h
new file mode 100644
index 0000000000000..858a078d939d0
--- /dev/null
+++ b/ui/aura/agl/window_tree_host_agl.h
@@ -0,0 +1,42 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef UI_AURA_AGL_WINDOW_TREE_HOST_AGL_H_
+#define UI_AURA_AGL_WINDOW_TREE_HOST_AGL_H_
+
+#include <string>
+
+#include "ui/aura/aura_export.h"
+
+namespace aura {
+
+class AURA_EXPORT WindowTreeHostAgl {
+ public:
+  WindowTreeHostAgl() = default;
+  WindowTreeHostAgl(const WindowTreeHostAgl&) = delete;
+  WindowTreeHostAgl& operator=(const WindowTreeHostAgl&) = delete;
+  ~WindowTreeHostAgl() = default;
+
+  virtual void SetAglActivateApp(const std::string& app) {}
+  virtual void SetAglAppId(const std::string& title) {}
+  virtual void SetAglReady() {}
+  virtual void SetAglBackground() {}
+  virtual void SetAglPanel(uint32_t edge) {}
+};
+
+}  // namespace aura
+
+#endif  // UI_AURA_AGL_WINDOW_TREE_HOST_AGL_H_
diff --git a/ui/aura/agl/window_tree_host_platform_agl.cc b/ui/aura/agl/window_tree_host_platform_agl.cc
new file mode 100644
index 0000000000000..e34595fe0ed9c
--- /dev/null
+++ b/ui/aura/agl/window_tree_host_platform_agl.cc
@@ -0,0 +1,50 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include "ui/aura/agl/window_tree_host_platform_agl.h"
+
+#include "ui/aura/window_tree_host_platform.h"
+#include "ui/platform_window/platform_window.h"
+
+namespace aura {
+
+WindowTreeHostPlatformAgl::WindowTreeHostPlatformAgl(
+    std::unique_ptr<Window> window,
+    aura::WindowTreeHostPlatform* window_tree_host_platform)
+    : aura::WindowTreeHost(std::move(window)),
+      window_tree_host_platform_(window_tree_host_platform) {}
+
+void WindowTreeHostPlatformAgl::SetAglActivateApp(const std::string& app) {
+  window_tree_host_platform_->platform_window()->SetAglActivateApp(app);
+}
+
+void WindowTreeHostPlatformAgl::SetAglAppId(const std::string& title) {
+  window_tree_host_platform_->platform_window()->SetAglAppId(title);
+}
+
+void WindowTreeHostPlatformAgl::SetAglReady() {
+  window_tree_host_platform_->platform_window()->SetAglReady();
+}
+
+void WindowTreeHostPlatformAgl::SetAglBackground() {
+  window_tree_host_platform_->platform_window()->SetAglBackground();
+}
+
+void WindowTreeHostPlatformAgl::SetAglPanel(uint32_t edge) {
+  window_tree_host_platform_->platform_window()->SetAglPanel(edge);
+}
+
+}  // namespace aura
diff --git a/ui/aura/agl/window_tree_host_platform_agl.h b/ui/aura/agl/window_tree_host_platform_agl.h
new file mode 100644
index 0000000000000..181eefae346f7
--- /dev/null
+++ b/ui/aura/agl/window_tree_host_platform_agl.h
@@ -0,0 +1,51 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef UI_AURA_AGL_WINDOW_TREE_HOST_PLATFORM_AGL_H_
+#define UI_AURA_AGL_WINDOW_TREE_HOST_PLATFORM_AGL_H_
+
+#include <memory>
+
+#include "ui/aura/aura_export.h"
+#include "ui/aura/window_tree_host.h"
+
+namespace aura {
+
+class Window;
+class WindowTreeHostPlatform;
+
+class AURA_EXPORT WindowTreeHostPlatformAgl : public aura::WindowTreeHost {
+ public:
+  explicit WindowTreeHostPlatformAgl(
+      std::unique_ptr<Window> window,
+      aura::WindowTreeHostPlatform* window_tree_host_platform);
+  WindowTreeHostPlatformAgl(const WindowTreeHostPlatformAgl&) = delete;
+  WindowTreeHostPlatformAgl& operator=(const WindowTreeHostPlatformAgl&) = delete;
+  ~WindowTreeHostPlatformAgl() override = default;
+
+  void SetAglActivateApp(const std::string& app) override;
+  void SetAglAppId(const std::string& title) override;
+  void SetAglReady() override;
+  void SetAglBackground() override;
+  void SetAglPanel(uint32_t edge) override;
+
+ private:
+  aura::WindowTreeHostPlatform* window_tree_host_platform_;
+};
+
+}  // namespace aura
+
+#endif  // UI_AURA_AGL_WINDOW_TREE_HOST_PLATFORM_AGL_H_
diff --git a/ui/aura/window_tree_host.h b/ui/aura/window_tree_host.h
index 0bdb86be66ba3..b7696e6373284 100644
--- a/ui/aura/window_tree_host.h
+++ b/ui/aura/window_tree_host.h
@@ -30,6 +30,8 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/gfx/overlay_transform.h"
 
+#include "ui/aura/agl/window_tree_host_agl.h"
+
 namespace gfx {
 class Point;
 class Rect;
@@ -66,7 +68,8 @@ class WindowTreeHostObserver;
 class AURA_EXPORT WindowTreeHost : public ui::ImeKeyEventDispatcher,
                                    public ui::EventSource,
                                    public display::DisplayObserver,
-                                   public ui::CompositorObserver {
+                                   public ui::CompositorObserver,
+                                   public WindowTreeHostAgl {
  public:
   // VideoCaptureLock ensures state necessary for capturing video remains in
   // effect. For example, this may force keeping the compositor visible when
diff --git a/ui/aura/window_tree_host_platform.cc b/ui/aura/window_tree_host_platform.cc
index 4c31e785d7692..cecd1f4fc03fd 100644
--- a/ui/aura/window_tree_host_platform.cc
+++ b/ui/aura/window_tree_host_platform.cc
@@ -51,7 +51,7 @@ std::unique_ptr<WindowTreeHost> WindowTreeHost::Create(
 WindowTreeHostPlatform::WindowTreeHostPlatform(
     ui::PlatformWindowInitProperties properties,
     std::unique_ptr<Window> window)
-    : WindowTreeHost(std::move(window)) {
+    : WindowTreeHostPlatformAgl(std::move(window), this) {
   size_in_pixels_ = properties.bounds.size();
   CreateCompositor(false, false, properties.enable_compositing_based_throttling,
                    properties.compositor_memory_limit_mb);
@@ -59,7 +59,7 @@ WindowTreeHostPlatform::WindowTreeHostPlatform(
 }
 
 WindowTreeHostPlatform::WindowTreeHostPlatform(std::unique_ptr<Window> window)
-    : WindowTreeHost(std::move(window)),
+    : WindowTreeHostPlatformAgl(std::move(window), this),
       widget_(gfx::kNullAcceleratedWidget),
       current_cursor_(ui::mojom::CursorType::kNull) {}
 
diff --git a/ui/aura/window_tree_host_platform.h b/ui/aura/window_tree_host_platform.h
index 3a9232743bda3..6c1e3a424afd4 100644
--- a/ui/aura/window_tree_host_platform.h
+++ b/ui/aura/window_tree_host_platform.h
@@ -15,6 +15,8 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/platform_window/platform_window_delegate.h"
 
+#include "ui/aura/agl/window_tree_host_platform_agl.h"
+
 namespace ui {
 enum class DomCode;
 class PlatformWindow;
@@ -26,7 +28,7 @@ namespace aura {
 
 // The unified WindowTreeHost implementation for platforms
 // that implement PlatformWindow.
-class AURA_EXPORT WindowTreeHostPlatform : public WindowTreeHost,
+class AURA_EXPORT WindowTreeHostPlatform : public WindowTreeHostPlatformAgl,
                                            public ui::PlatformWindowDelegate {
  public:
   explicit WindowTreeHostPlatform(ui::PlatformWindowInitProperties properties,
diff --git a/ui/ozone/platform/wayland/BUILD.gn b/ui/ozone/platform/wayland/BUILD.gn
index 1a2f889dc8947..86ff8269af9e0 100644
--- a/ui/ozone/platform/wayland/BUILD.gn
+++ b/ui/ozone/platform/wayland/BUILD.gn
@@ -409,7 +409,6 @@ source_set("wayland") {
 
   sources += [
    "host/wayland_extensions.h",
-   "host/wayland_extensions_stub.cc",
   ]
 
   deps += [ "extensions/agl" ]
diff --git a/ui/ozone/platform/wayland/extensions/agl/BUILD.gn b/ui/ozone/platform/wayland/extensions/agl/BUILD.gn
index ce289bc5dbbca..01c590e53df58 100644
--- a/ui/ozone/platform/wayland/extensions/agl/BUILD.gn
+++ b/ui/ozone/platform/wayland/extensions/agl/BUILD.gn
@@ -31,6 +31,8 @@ source_set("agl") {
     "host/wayland_extensions_agl.h",
     "host/wayland_extensions_agl_impl.cc",
     "host/wayland_extensions_agl_impl.h",
+    "host/wayland_window_agl.cc",
+    "host/wayland_window_agl.h",
   ]
 
   deps = [
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h
index df42fc00c84da..295154dfb437d 100644
--- a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h
@@ -20,6 +20,9 @@
 namespace ui {
 
 class AglShellWrapper;
+class PlatformWindowDelegate;
+class WaylandConnection;
+class WaylandWindow;
 
 // AGL extensions implementation for webOS/Lite
 class WaylandExtensionsAgl {
@@ -29,9 +32,14 @@ class WaylandExtensionsAgl {
   WaylandExtensionsAgl& operator=(const WaylandExtensionsAgl&) = delete;
   virtual ~WaylandExtensionsAgl() = default;
 
+  virtual std::unique_ptr<WaylandWindow> CreateWaylandWindow(
+      PlatformWindowDelegate* delegate,
+      WaylandConnection* connection) = 0;
+
+
   virtual AglShellWrapper* GetAglShell() = 0;
 };
 
 }  // namespace ui
 
-#endif  // UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_H_
\ No newline at end of file
+#endif  // UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_H_
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc
index 26a5f0550c302..87376cbb8a9d3 100644
--- a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.cc
@@ -22,6 +22,7 @@
 #include "base/logging.h"
 #include "ui/base/ui_base_switches.h"
 #include "ui/ozone/platform/wayland/extensions/agl/host/agl_shell_wrapper.h"
+#include "ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h"
 #include "ui/ozone/platform/wayland/extensions/agl/common/wayland_object_agl.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 
@@ -68,8 +69,8 @@ bool WaylandExtensionsAglImpl::Bind(wl_registry* registry,
     agl_shell_ =
         std::make_unique<AglShellWrapper>(aglshell.release(), connection_);
 
-    LOG(INFO) << "Waiting until bound...";
-    return agl_shell_->WaitUntilBoundOk();
+    //LOG(INFO) << "Waiting until bound...";
+    //return agl_shell_->WaitUntilBoundOk();
   } else {
     LOG(INFO) << "Cant bind.";
   }
@@ -85,6 +86,12 @@ AglShellWrapper* WaylandExtensionsAglImpl::GetAglShell() {
   return agl_shell_.get();
 }
 
+std::unique_ptr<WaylandWindow> WaylandExtensionsAglImpl::CreateWaylandWindow(
+    PlatformWindowDelegate* delegate,
+    WaylandConnection* connection) {
+  return std::make_unique<WaylandWindowAgl>(delegate, connection, this);
+}
+
 std::unique_ptr<WaylandExtensions> CreateWaylandExtensions(
     WaylandConnection* connection) {
   return std::make_unique<WaylandExtensionsAglImpl>(connection);
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h
index f6cbabe99ed0b..3218589f1a09a 100644
--- a/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl_impl.h
@@ -17,12 +17,17 @@
 #ifndef UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_IMPL_H_
 #define UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_EXTENSIONS_AGL_IMPL_H_
 
+#include <memory>
+
 #include "ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h"
 #include "ui/ozone/platform/wayland/host/wayland_extensions.h"
 
 namespace ui {
 
 class AglShellWrapper;
+class PlatformWindowDelegate;
+class WaylandConnection;
+class WaylandWindow;
 
 // AGL extension implementation for webOS/Lite
 class WaylandExtensionsAglImpl : public WaylandExtensions,
@@ -44,6 +49,10 @@ class WaylandExtensionsAglImpl : public WaylandExtensions,
   // WaylandExtensionsAgl overrides
   AglShellWrapper* GetAglShell() override;
 
+  std::unique_ptr<WaylandWindow> CreateWaylandWindow(
+      PlatformWindowDelegate* delegate,
+      WaylandConnection* connection) override;
+
  private:
   std::unique_ptr<AglShellWrapper> agl_shell_;
   WaylandConnection* connection_;
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc
new file mode 100644
index 0000000000000..97b21ae537658
--- /dev/null
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.cc
@@ -0,0 +1,86 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#include "ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h"
+
+#include "base/logging.h"
+#include "ui/ozone/platform/wayland/extensions/agl/host/agl_shell_wrapper.h"
+#include "ui/ozone/platform/wayland/extensions/agl/host/wayland_extensions_agl.h"
+#include "ui/ozone/platform/wayland/host/shell_surface_wrapper.h"
+#include "ui/ozone/platform/wayland/host/shell_toplevel_wrapper.h"
+#include "ui/ozone/platform/wayland/host/wayland_connection.h"
+
+namespace ui {
+
+WaylandWindowAgl::WaylandWindowAgl(PlatformWindowDelegate* delegate,
+                                   WaylandConnection* connection,
+                                   WaylandExtensionsAgl* agl_extensions)
+    : WaylandToplevelWindow(delegate, connection),
+      agl_extensions_(agl_extensions) {}
+
+WaylandWindowAgl::~WaylandWindowAgl() = default;
+
+void WaylandWindowAgl::SetAglActivateApp(const std::string& app) {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglActivateApp(app);
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglAppId(const std::string& title) {
+  if (!shell_toplevel()) {
+    LOG(ERROR) << "Shell toplevel is not created";
+    return;
+  }
+
+  shell_toplevel()->SetAppId(title);
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglReady() {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglReady();
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglBackground() {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglBackground(this);
+  connection()->ScheduleFlush();
+}
+
+void WaylandWindowAgl::SetAglPanel(uint32_t edge) {
+  if (!agl_extensions_->GetAglShell()) {
+    LOG(ERROR) << "Agl shell wrapper is not created";
+    return;
+  }
+
+  agl_extensions_->GetAglShell()->SetAglPanel(this, edge);
+  connection()->ScheduleFlush();
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h
new file mode 100644
index 0000000000000..b2a922604c001
--- /dev/null
+++ b/ui/ozone/platform/wayland/extensions/agl/host/wayland_window_agl.h
@@ -0,0 +1,49 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+//
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_WINDOW_AGL_H_
+#define UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_WINDOW_AGL_H_
+
+#include "ui/ozone/platform/wayland/host/wayland_toplevel_window.h"
+
+namespace ui {
+
+class WaylandExtensionsAgl;
+
+class WaylandWindowAgl : public WaylandToplevelWindow {
+ public:
+  explicit WaylandWindowAgl(PlatformWindowDelegate* delegate,
+                            WaylandConnection* connection,
+                            WaylandExtensionsAgl* agl_extensions);
+  WaylandWindowAgl(const WaylandWindowAgl&) = delete;
+  WaylandWindowAgl& operator=(const WaylandWindowAgl&) = delete;
+  ~WaylandWindowAgl() override;
+
+  // Overrides PlatformWindowAgl
+  void SetAglActivateApp(const std::string& app) override;
+  void SetAglAppId(const std::string& title) override;
+  void SetAglReady() override;
+  void SetAglBackground() override;
+  void SetAglPanel(uint32_t edge) override;
+
+ private:
+  WaylandExtensionsAgl* agl_extensions_;
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_EXTENSIONS_AGL_HOST_WAYLAND_WINDOW_AGL_H_
diff --git a/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc b/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc
index 1cef91bb39912..1a4f9d7df7a55 100644
--- a/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc
+++ b/ui/ozone/platform/wayland/gpu/gl_surface_wayland.cc
@@ -79,7 +79,7 @@ EGLConfig GLSurfaceWayland::GetConfig() {
 
 gfx::SwapResult GLSurfaceWayland::SwapBuffers(PresentationCallback callback,
                                               gl::FrameData data) {
-  UpdateVisualSize();
+  /*UpdateVisualSize();
   if (!window_->IsSurfaceConfigured()) {
     // The presentation |callback| must be called after gfx::SwapResult is sent.
     // Thus, use a scoped swap buffers object that will send the feedback later.
@@ -88,9 +88,15 @@ gfx::SwapResult GLSurfaceWayland::SwapBuffers(PresentationCallback callback,
     scoped_swap_buffers.set_result(gfx::SwapResult::SWAP_NAK_RECREATE_BUFFERS);
     return scoped_swap_buffers.result();
   }
-  window_->root_surface()->set_surface_buffer_scale(scale_factor_);
-  return gl::NativeViewGLSurfaceEGL::SwapBuffers(std::move(callback),
-                                                 std::move(data));
+  window_->root_surface()->set_surface_buffer_scale(scale_factor_);*/
+  gfx::SwapResult result = gl::NativeViewGLSurfaceEGL::SwapBuffers(std::move(callback),
+                                                                   std::move(data));
+
+  if (window_) {
+    window_->OnSurfaceContentChanged();
+  }
+
+  return result;
 }
 
 gfx::SwapResult GLSurfaceWayland::PostSubBuffer(int x,
diff --git a/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc b/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc
index 43445ea2442b4..94f0739599142 100644
--- a/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc
+++ b/ui/ozone/platform/wayland/host/gtk_primary_selection_device.cc
@@ -31,7 +31,7 @@ void GtkPrimarySelectionDevice::SetSelectionSource(
   auto* data_source = source ? source->data_source() : nullptr;
   gtk_primary_selection_device_set_selection(data_device_.get(), data_source,
                                              serial);
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc b/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc
index 2c39409808128..1e07ae6009776 100644
--- a/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc
+++ b/ui/ozone/platform/wayland/host/gtk_primary_selection_device_manager.cc
@@ -66,7 +66,7 @@ GtkPrimarySelectionDevice* GtkPrimarySelectionDeviceManager::GetDevice() {
         connection_,
         gtk_primary_selection_device_manager_get_device(
             device_manager_.get(), connection_->seat()->wl_object()));
-    connection_->Flush();
+    connection_->ScheduleFlush();
   }
   DCHECK(device_);
   return device_.get();
@@ -77,7 +77,7 @@ GtkPrimarySelectionDeviceManager::CreateSource(
     GtkPrimarySelectionSource::Delegate* delegate) {
   auto* data_source =
       gtk_primary_selection_device_manager_create_source(device_manager_.get());
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return std::make_unique<GtkPrimarySelectionSource>(data_source, connection_,
                                                      delegate);
 }
diff --git a/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc b/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc
index dee90b1aaaf72..caad70e0ab1cb 100644
--- a/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc
+++ b/ui/ozone/platform/wayland/host/proxy/wayland_proxy_impl.cc
@@ -75,7 +75,7 @@ void WaylandProxyImpl::DestroyShmForWlBuffer(wl_buffer* buffer) {
 }
 
 void WaylandProxyImpl::FlushForTesting() {
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 ui::PlatformWindowType WaylandProxyImpl::GetWindowType(
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.cc b/ui/ozone/platform/wayland/host/wayland_connection.cc
index 93427c52e1284..e2d45a6f5dc67 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.cc
+++ b/ui/ozone/platform/wayland/host/wayland_connection.cc
@@ -285,6 +285,20 @@ bool WaylandConnection::Initialize() {
   return true;
 }
 
+void WaylandConnection::ScheduleFlush() {
+  // When we are in tests, the message loop is set later when the
+  // initialization of the OzonePlatform complete. Thus, just
+  // flush directly. This doesn't happen in normal run.
+  if (!base::CurrentUIThread::IsSet()) {
+    Flush();
+  } else if (!scheduled_flush_) {
+    base::ThreadTaskRunnerHandle::Get()->PostTask(
+        FROM_HERE,
+        base::BindOnce(&WaylandConnection::Flush, base::Unretained(this)));
+    scheduled_flush_ = true;
+  }
+}
+
 void WaylandConnection::RoundTripQueue() {
   if (roundtrip_closure_for_testing_) {
     roundtrip_closure_for_testing_.Run();
@@ -354,6 +368,7 @@ void WaylandConnection::RegisterGlobalObjectFactory(
 
 void WaylandConnection::Flush() {
   wl_display_flush(display_.get());
+  scheduled_flush_ = false;
 }
 
 void WaylandConnection::UpdateInputDevices() {
@@ -441,7 +456,7 @@ void WaylandConnection::Global(void* data,
 
   auto factory_it = connection->global_object_factories_.find(interface);
   if (connection->extensions_->Bind(registry, name, interface, version)) {
-    DVLOG(1) << "Successfully bound to " << interface;
+    LOG(INFO) << "Successfully bound to " << interface;
   } else if (factory_it != connection->global_object_factories_.end()) {
     (*factory_it->second)(connection, registry, name, interface, version);
   } else if (!connection->compositor_ &&
@@ -609,7 +624,7 @@ void WaylandConnection::Global(void* data,
 
   connection->available_globals_.emplace_back(interface, version);
 
-  connection->Flush();
+  connection->ScheduleFlush();
 }
 
 base::TimeTicks WaylandConnection::ConvertPresentationTime(uint32_t tv_sec_hi,
@@ -674,14 +689,14 @@ void WaylandConnection::PingV6(void* data,
                                uint32_t serial) {
   WaylandConnection* connection = static_cast<WaylandConnection*>(data);
   zxdg_shell_v6_pong(shell_v6, serial);
-  connection->Flush();
+  connection->ScheduleFlush();
 }
 
 // static
 void WaylandConnection::Ping(void* data, xdg_wm_base* shell, uint32_t serial) {
   WaylandConnection* connection = static_cast<WaylandConnection*>(data);
   xdg_wm_base_pong(shell, serial);
-  connection->Flush();
+  connection->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/wayland_connection.h b/ui/ozone/platform/wayland/host/wayland_connection.h
index dfd1d060c73f2..d2d7a866d3af8 100644
--- a/ui/ozone/platform/wayland/host/wayland_connection.h
+++ b/ui/ozone/platform/wayland/host/wayland_connection.h
@@ -94,8 +94,8 @@ class WaylandConnection {
 
   bool Initialize();
 
-  // Immediately flushes the Wayland display.
-  void Flush();
+  // Schedules a flush of the Wayland connection.
+  void ScheduleFlush();
 
   // Calls wl_display_roundtrip_queue. Might be required during initialization
   // of some objects that should block until they are initialized.
@@ -340,6 +340,9 @@ class WaylandConnection {
   friend class ZwpIdleInhibitManager;
   friend class ZwpPrimarySelectionDeviceManager;
 
+  // Immediately flushes the Wayland display.
+  void Flush();
+
   void RegisterGlobalObjectFactory(const char* interface_name,
                                    wl::GlobalObjectFactory factory);
 
@@ -467,6 +470,8 @@ class WaylandConnection {
   // sizes.
   bool surface_submission_in_pixel_coordinates_ = false;
 
+  bool scheduled_flush_ = false;
+
   wl::SerialTracker serial_tracker_;
 
   // Global Wayland interfaces available in the current session, with their
diff --git a/ui/ozone/platform/wayland/host/wayland_cursor.cc b/ui/ozone/platform/wayland/host/wayland_cursor.cc
index 891ca2e5e1f3c..48ac8b8925ddd 100644
--- a/ui/ozone/platform/wayland/host/wayland_cursor.cc
+++ b/ui/ozone/platform/wayland/host/wayland_cursor.cc
@@ -109,7 +109,7 @@ void WaylandCursor::HideCursor() {
   wl_surface_attach(pointer_surface_.get(), nullptr, 0, 0);
   wl_surface_commit(pointer_surface_.get());
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   if (listener_)
     listener_->OnCursorBufferAttached(nullptr);
@@ -160,7 +160,7 @@ void WaylandCursor::AttachAndCommit(wl_buffer* buffer,
   wl_surface_attach(pointer_surface_.get(), buffer, 0, 0);
   wl_surface_commit(pointer_surface_.get());
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_data_device.cc b/ui/ozone/platform/wayland/host/wayland_data_device.cc
index a1d691b6315ac..ccc7bfb0305a8 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_device.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_device.cc
@@ -46,7 +46,7 @@ void WaylandDataDevice::StartDrag(const WaylandDataSource& data_source,
                             origin_window.root_surface()->surface(),
                             icon_surface, serial);
   drag_delegate_->DrawIcon();
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandDataDevice::ResetDragDelegate() {
@@ -78,7 +78,7 @@ void WaylandDataDevice::SetSelectionSource(WaylandDataSource* source,
                                            uint32_t serial) {
   auto* data_source = source ? source->data_source() : nullptr;
   wl_data_device_set_selection(data_device_.get(), data_source, serial);
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandDataDevice::ReadDragDataFromFD(base::ScopedFD fd,
@@ -140,7 +140,7 @@ void WaylandDataDevice::OnEnter(void* data,
       gfx::PointF(wl_fixed_to_double(x), wl_fixed_to_double(y)), window);
   self->drag_delegate_->OnDragEnter(window, point, serial);
 
-  self->connection()->Flush();
+  self->connection()->ScheduleFlush();
 }
 
 void WaylandDataDevice::OnMotion(void* data,
@@ -161,7 +161,7 @@ void WaylandDataDevice::OnDrop(void* data, wl_data_device* data_device) {
   auto* self = static_cast<WaylandDataDevice*>(data);
   if (self->drag_delegate_) {
     self->drag_delegate_->OnDragDrop();
-    self->connection()->Flush();
+    self->connection()->ScheduleFlush();
   }
 
   // There are buggy Exo versions, which send 'drop' event (even for
@@ -178,7 +178,7 @@ void WaylandDataDevice::OnLeave(void* data, wl_data_device* data_device) {
   auto* self = static_cast<WaylandDataDevice*>(data);
   if (self->drag_delegate_) {
     self->drag_delegate_->OnDragLeave();
-    self->connection()->Flush();
+    self->connection()->ScheduleFlush();
   }
   self->ResetDragDelegateIfNeeded();
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_data_device_base.cc b/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
index 4287f72617708..d0c077c2e69ea 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_device_base.cc
@@ -72,7 +72,7 @@ void WaylandDataDeviceBase::RegisterDeferredReadCallback() {
 
   wl_callback_add_listener(deferred_read_callback_.get(), &kListener, this);
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 void WaylandDataDeviceBase::RegisterDeferredReadClosure(
diff --git a/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc b/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
index f2123ec8bac3f..11750a3f55da2 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_drag_controller.cc
@@ -217,7 +217,7 @@ void WaylandDataDragController::OnDragSurfaceFrame(void* data,
   DCHECK(self);
   self->DrawIconInternal();
   self->icon_frame_callback_.reset();
-  self->connection_->Flush();
+  self->connection_->ScheduleFlush();
 }
 
 void WaylandDataDragController::DrawIconInternal() {
diff --git a/ui/ozone/platform/wayland/host/wayland_data_source.cc b/ui/ozone/platform/wayland/host/wayland_data_source.cc
index de1e110f73b11..e24f31b1a8f52 100644
--- a/ui/ozone/platform/wayland/host/wayland_data_source.cc
+++ b/ui/ozone/platform/wayland/host/wayland_data_source.cc
@@ -119,7 +119,7 @@ void DataSource<wl_data_source>::Offer(
     const std::vector<std::string>& mime_types) {
   for (auto& mime_type : mime_types)
     wl_data_source_offer(data_source_.get(), mime_type.c_str());
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template <typename T>
@@ -154,7 +154,7 @@ void DataSource<gtk_primary_selection_source>::Offer(
     const std::vector<std::string>& mime_types) {
   for (const auto& mime_type : mime_types)
     gtk_primary_selection_source_offer(data_source_.get(), mime_type.c_str());
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template <>
@@ -173,7 +173,7 @@ void DataSource<zwp_primary_selection_source_v1>::Offer(
   for (const auto& mime_type : mime_types)
     zwp_primary_selection_source_v1_offer(data_source_.get(),
                                           mime_type.c_str());
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template class DataSource<gtk_primary_selection_source>;
diff --git a/ui/ozone/platform/wayland/host/wayland_drm.cc b/ui/ozone/platform/wayland/host/wayland_drm.cc
index 7edc0da798b9b..280350d9286c0 100644
--- a/ui/ozone/platform/wayland/host/wayland_drm.cc
+++ b/ui/ozone/platform/wayland/host/wayland_drm.cc
@@ -57,7 +57,7 @@ WaylandDrm::WaylandDrm(wl_drm* drm, WaylandConnection* connection)
       &Capabilities,
   };
   wl_drm_add_listener(wl_drm_.get(), &kDrmListener, this);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   // A roundtrip after binding guarantees that the client has received all
   // supported formats and capabilities of the device.
@@ -91,7 +91,7 @@ void WaylandDrm::CreateBuffer(const base::ScopedFD& fd,
   wl::Object<wl_buffer> buffer(wl_drm_create_prime_buffer(
       wl_drm_.get(), fd.get(), size.width(), size.height(), format, offset[0],
       stride[0], offset[1], stride[1], offset[2], stride[2]));
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   std::move(callback).Run(std::move(buffer));
 }
@@ -145,7 +145,7 @@ void WaylandDrm::Authenticate(const char* drm_device_path) {
   }
 
   wl_drm_authenticate(wl_drm_.get(), magic);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   // Do the roundtrip to make sure the server processes this request and
   // authenticates us.
diff --git a/ui/ozone/platform/wayland/host/wayland_extensions.h b/ui/ozone/platform/wayland/host/wayland_extensions.h
index 3bd2fd7a211ae..f6ed47507d217 100644
--- a/ui/ozone/platform/wayland/host/wayland_extensions.h
+++ b/ui/ozone/platform/wayland/host/wayland_extensions.h
@@ -25,7 +25,9 @@ namespace ui {
 
 class ShellToplevelWrapper;
 class ShellPopupWrapper;
+class PlatformWindowDelegate;
 class WaylandConnection;
+class WaylandWindow;
 
 // Wayland extensions abstract interface to support extending of the Wayland
 // protocol. Inherit it to provide your own Wayland extensions implementation.
@@ -45,6 +47,10 @@ class WaylandExtensions {
 
   // Checks whether the extensions have bound shell object(s).
   virtual bool HasShellObject() const = 0;
+
+  virtual std::unique_ptr<WaylandWindow> CreateWaylandWindow(
+      PlatformWindowDelegate* delegate,
+      WaylandConnection* connection) = 0;
 };
 
 // Creates Wayland extensions.
diff --git a/ui/ozone/platform/wayland/host/wayland_keyboard.cc b/ui/ozone/platform/wayland/host/wayland_keyboard.cc
index c6e64f1e55da3..473a702bf8987 100644
--- a/ui/ozone/platform/wayland/host/wayland_keyboard.cc
+++ b/ui/ozone/platform/wayland/host/wayland_keyboard.cc
@@ -54,7 +54,7 @@ class WaylandKeyboard::ZCRExtendedKeyboard {
 
   void AckKey(uint32_t serial, bool handled) {
     zcr_extended_keyboard_v1_ack_key(obj_.get(), serial, handled);
-    keyboard_->connection_->Flush();
+    keyboard_->connection_->ScheduleFlush();
   }
 
   // Returns true if connected object will send zcr_extended_keyboard::peek_key.
@@ -247,7 +247,7 @@ void WaylandKeyboard::FlushInput(base::OnceClosure closure) {
   // get spurious repeats.
   sync_callback_.reset(wl_display_sync(connection_->display_wrapper()));
   wl_callback_add_listener(sync_callback_.get(), &callback_listener_, this);
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 void WaylandKeyboard::DispatchKey(unsigned int key,
diff --git a/ui/ozone/platform/wayland/host/wayland_popup.cc b/ui/ozone/platform/wayland/host/wayland_popup.cc
index 84e429457462e..cb13557093dc2 100644
--- a/ui/ozone/platform/wayland/host/wayland_popup.cc
+++ b/ui/ozone/platform/wayland/host/wayland_popup.cc
@@ -124,7 +124,7 @@ void WaylandPopup::Show(bool inactive) {
     return;
   }
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
   WaylandWindow::Show(inactive);
 }
 
@@ -147,7 +147,7 @@ void WaylandPopup::Hide() {
     decorated_via_aura_popup_ = false;
   }
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 bool WaylandPopup::IsVisible() const {
diff --git a/ui/ozone/platform/wayland/host/wayland_shm.cc b/ui/ozone/platform/wayland/host/wayland_shm.cc
index 80d27227b9ab3..2b6c4f31ca0d8 100644
--- a/ui/ozone/platform/wayland/host/wayland_shm.cc
+++ b/ui/ozone/platform/wayland/host/wayland_shm.cc
@@ -62,7 +62,7 @@ wl::Object<wl_buffer> WaylandShm::CreateBuffer(const base::ScopedFD& fd,
       with_alpha_channel ? WL_SHM_FORMAT_ARGB8888 : WL_SHM_FORMAT_XRGB8888;
   wl::Object<wl_buffer> shm_buffer(wl_shm_pool_create_buffer(
       pool.get(), 0, size.width(), size.height(), size.width() * 4, format));
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return shm_buffer;
 }
 
diff --git a/ui/ozone/platform/wayland/host/wayland_surface.cc b/ui/ozone/platform/wayland/host/wayland_surface.cc
index cd178f9aaee00..ffe5062402b33 100644
--- a/ui/ozone/platform/wayland/host/wayland_surface.cc
+++ b/ui/ozone/platform/wayland/host/wayland_surface.cc
@@ -267,7 +267,7 @@ void WaylandSurface::UpdateBufferDamageRegion(const gfx::Rect& damage_px) {
 void WaylandSurface::Commit(bool flush) {
   wl_surface_commit(surface_.get());
   if (flush)
-    connection_->Flush();
+    connection_->ScheduleFlush();
 }
 
 void WaylandSurface::set_surface_buffer_scale(float scale) {
diff --git a/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc b/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc
index e39daa898c9a5..68aebd357fdc2 100644
--- a/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc
+++ b/ui/ozone/platform/wayland/host/wayland_toplevel_window.cc
@@ -131,7 +131,7 @@ void WaylandToplevelWindow::DispatchHostWindowDragMovement(
   else
     shell_toplevel_->SurfaceResize(connection(), hittest);
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandToplevelWindow::Show(bool inactive) {
@@ -166,7 +166,7 @@ void WaylandToplevelWindow::Hide() {
     aura_surface_.reset();
   }
   shell_toplevel_.reset();
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 bool WaylandToplevelWindow::IsVisible() const {
@@ -183,7 +183,7 @@ void WaylandToplevelWindow::SetTitle(const std::u16string& title) {
 
   if (shell_toplevel_) {
     shell_toplevel_->SetTitle(title);
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
@@ -262,13 +262,13 @@ void WaylandToplevelWindow::Activate() {
   // but nothing more happens (until the user moves the mouse over a Lacros
   // window in which case events will start and the activation will come
   // through).
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandToplevelWindow::Deactivate() {
   if (shell_toplevel_ && shell_toplevel_->SupportsActivation()) {
     shell_toplevel_->Deactivate();
-    connection()->Flush();
+    connection()->ScheduleFlush();
   }
 }
 
@@ -877,7 +877,7 @@ void WaylandToplevelWindow::TriggerStateChanges() {
 
   delegate()->OnWindowStateChanged(previous_state_, state_);
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandToplevelWindow::SetWindowState(PlatformWindowState state) {
@@ -908,7 +908,7 @@ void WaylandToplevelWindow::SetSizeConstraints() {
   if (max_size_dip.has_value())
     shell_toplevel_->SetMaxSize(max_size_dip->width(), max_size_dip->height());
 
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 void WaylandToplevelWindow::SetOrResetRestoredBounds() {
diff --git a/ui/ozone/platform/wayland/host/wayland_window.cc b/ui/ozone/platform/wayland/host/wayland_window.cc
index f8b8c36a745e5..e415efde8ccd8 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window.cc
@@ -430,7 +430,7 @@ void WaylandWindow::SetDecorationInsets(const gfx::Insets* insets_px) {
   else
     frame_insets_px_ = absl::nullopt;
   UpdateDecorations();
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 void WaylandWindow::SetWindowIcons(const gfx::ImageSkia& window_icon,
@@ -522,6 +522,10 @@ void WaylandWindow::HandleSurfaceConfigure(uint32_t serial) {
       << "Only shell surfaces must receive HandleSurfaceConfigure calls.";
 }
 
+void WaylandWindow::OnSurfaceContentChanged() {
+  connection_->ScheduleFlush();
+}
+
 void WaylandWindow::HandleToplevelConfigure(int32_t widht,
                                             int32_t height,
                                             const WindowStates& window_states) {
@@ -551,7 +555,7 @@ void WaylandWindow::UpdateVisualSize(const gfx::Size& size_px) {
 
   if (apply_pending_state_on_update_visual_size_for_testing_) {
     root_surface_->ApplyPendingState();
-    connection_->Flush();
+    connection_->ScheduleFlush();
   }
 }
 
@@ -661,7 +665,7 @@ bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
   std::vector<gfx::Rect> region{gfx::Rect{size_px_}};
   root_surface_->set_opaque_region(&region);
   root_surface_->ApplyPendingState();
-  connection_->Flush();
+  connection_->ScheduleFlush();
 
   return true;
 }
@@ -957,7 +961,7 @@ void WaylandWindow::ProcessPendingBoundsDip(uint32_t serial) {
     // window has been applied.
     SetWindowGeometry(pending_bounds_dip_);
     AckConfigure(serial);
-    connection()->Flush();
+    connection()->ScheduleFlush();
   } else if (!pending_configures_.empty() &&
              pending_bounds_dip_.size() ==
                  pending_configures_.back().bounds_dip.size()) {
@@ -1051,7 +1055,7 @@ bool WaylandWindow::ProcessVisualSizeUpdate(const gfx::Size& size_px) {
     auto serial = result->serial;
     SetWindowGeometry(result->bounds_dip);
     AckConfigure(serial);
-    connection()->Flush();
+    connection()->ScheduleFlush();
     pending_configures_.erase(pending_configures_.begin(), ++result);
     return true;
   }
diff --git a/ui/ozone/platform/wayland/host/wayland_window.h b/ui/ozone/platform/wayland/host/wayland_window.h
index f0f75d4481cd2..dae1ddcd2933f 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.h
+++ b/ui/ozone/platform/wayland/host/wayland_window.h
@@ -218,6 +218,8 @@ class WaylandWindow : public PlatformWindow,
   // currently bound to.
   virtual void HandleSurfaceConfigure(uint32_t serial);
 
+  void OnSurfaceContentChanged();
+
   struct WindowStates {
     bool is_maximized = false;
     bool is_fullscreen = false;
diff --git a/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc b/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc
index 6f45f47a71c25..a269ec9b368a4 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_drag_controller.cc
@@ -84,7 +84,7 @@ class WaylandWindowDragController::ExtendedDragSource {
     auto* surface = window ? window->root_surface()->surface() : nullptr;
     zcr_extended_drag_source_v1_drag(source_.get(), surface, offset.x(),
                                      offset.y());
-    connection_.Flush();
+    connection_.ScheduleFlush();
   }
 
  private:
diff --git a/ui/ozone/platform/wayland/host/wayland_window_factory.cc b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
index 4857125bb5f34..b2f73218681b9 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_factory.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
@@ -13,6 +13,8 @@
 #include "ui/ozone/platform/wayland/host/wayland_window.h"
 #include "ui/platform_window/platform_window_init_properties.h"
 
+#include "ui/ozone/platform/wayland/host/wayland_extensions.h"
+
 namespace ui {
 
 namespace {
@@ -41,6 +43,13 @@ std::unique_ptr<WaylandWindow> WaylandWindow::Create(
       // toplevel window instead.
       if (auto* parent =
               GetParentWindow(connection, properties.parent_widget)) {
+
+        if (connection->extensions()) {
+          window = connection->extensions()->CreateWaylandWindow(delegate,
+                                                                 connection);
+          if (window)
+            break;
+        }
         window = std::make_unique<WaylandPopup>(delegate, connection, parent);
       } else {
         DLOG(WARNING) << "Failed to determine for menu/popup window.";
@@ -52,6 +61,12 @@ std::unique_ptr<WaylandWindow> WaylandWindow::Create(
     case PlatformWindowType::kDrag:
       // TODO(msisov): Figure out what kind of surface we need to create for
       // bubble and drag windows.
+      if (connection->extensions()) {
+        window =
+            connection->extensions()->CreateWaylandWindow(delegate, connection);
+        if (window)
+          break;
+      }
       window = std::make_unique<WaylandToplevelWindow>(delegate, connection);
       break;
     default:
diff --git a/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc b/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc
index 3db8cb5e5dba9..5d6293e016842 100644
--- a/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc
+++ b/ui/ozone/platform/wayland/host/wayland_zwp_linux_dmabuf.cc
@@ -104,7 +104,7 @@ void WaylandZwpLinuxDmabuf::CreateBuffer(const base::ScopedFD& fd,
     // created buffer and notify the client about it via the |callback|.
     pending_params_.emplace(std::move(params), std::move(callback));
   }
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 bool WaylandZwpLinuxDmabuf::CanCreateBufferImmed() const {
@@ -150,7 +150,7 @@ void WaylandZwpLinuxDmabuf::NotifyRequestCreateBufferDone(
 
   pending_params_.erase(it);
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc b/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc
index 8b8591fabe015..9b3c6e5136d5d 100644
--- a/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc
+++ b/ui/ozone/platform/wayland/host/xdg_foreign_wrapper.cc
@@ -162,7 +162,7 @@ void XdgForeignWrapperImpl<zxdg_exporter_v1, zxdg_exported_v1>::
   zxdg_exported_v1_add_listener(exported_surface.exported.get(),
                                 &kExportedListener, this);
   exported_surfaces_.emplace_back(std::move(exported_surface));
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 template <>
@@ -176,7 +176,7 @@ void XdgForeignWrapperImpl<zxdg_exporter_v2, zxdg_exported_v2>::
   zxdg_exported_v2_add_listener(exported_surface.exported.get(),
                                 &kExportedListener, this);
   exported_surfaces_.emplace_back(std::move(exported_surface));
-  connection_->Flush();
+  connection_->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc b/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
index 23b7ad8fbf3cc..2e1f8fc129bf7 100644
--- a/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
+++ b/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
@@ -230,7 +230,7 @@ bool XDGPopupWrapperImpl::SetBounds(const gfx::Rect& new_bounds) {
   xdg_popup_reposition(xdg_popup_.get(), positioner.get(),
                        ++next_reposition_token_);
 
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return true;
 }
 
diff --git a/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc b/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
index 048071b4b7b76..692f562e203f0 100644
--- a/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
+++ b/ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.cc
@@ -40,7 +40,7 @@ bool XDGSurfaceWrapperImpl::Initialize() {
   }
 
   xdg_surface_add_listener(xdg_surface_.get(), &xdg_surface_listener, this);
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return true;
 }
 
diff --git a/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc b/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc
index d02c76db80aa2..9e7e0a916d66d 100644
--- a/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc
+++ b/ui/ozone/platform/wayland/host/zwp_primary_selection_device.cc
@@ -31,7 +31,7 @@ void ZwpPrimarySelectionDevice::SetSelectionSource(
   auto* data_source = source ? source->data_source() : nullptr;
   zwp_primary_selection_device_v1_set_selection(data_device_.get(), data_source,
                                                 serial);
-  connection()->Flush();
+  connection()->ScheduleFlush();
 }
 
 // static
diff --git a/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc b/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc
index 9d5d79635b66d..2ca82ce6031ba 100644
--- a/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc
+++ b/ui/ozone/platform/wayland/host/zwp_primary_selection_device_manager.cc
@@ -66,7 +66,7 @@ ZwpPrimarySelectionDevice* ZwpPrimarySelectionDeviceManager::GetDevice() {
         connection_,
         zwp_primary_selection_device_manager_v1_get_device(
             device_manager_.get(), connection_->seat()->wl_object()));
-    connection_->Flush();
+    connection_->ScheduleFlush();
   }
   DCHECK(device_);
   return device_.get();
@@ -77,7 +77,7 @@ ZwpPrimarySelectionDeviceManager::CreateSource(
     ZwpPrimarySelectionSource::Delegate* delegate) {
   auto* data_source = zwp_primary_selection_device_manager_v1_create_source(
       device_manager_.get());
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return std::make_unique<ZwpPrimarySelectionSource>(data_source, connection_,
                                                      delegate);
 }
diff --git a/ui/ozone/platform/wayland/host/zxdg_surface_v6_wrapper_impl.cc b/ui/ozone/platform/wayland/host/zxdg_surface_v6_wrapper_impl.cc
index e900f9d37e8ad..5c4c538800f65 100644
--- a/ui/ozone/platform/wayland/host/zxdg_surface_v6_wrapper_impl.cc
+++ b/ui/ozone/platform/wayland/host/zxdg_surface_v6_wrapper_impl.cc
@@ -43,7 +43,7 @@ bool ZXDGSurfaceV6WrapperImpl::Initialize() {
 
   zxdg_surface_v6_add_listener(zxdg_surface_v6_.get(),
                                &zxdg_surface_v6_listener, this);
-  connection_->Flush();
+  connection_->ScheduleFlush();
   return true;
 }
 
diff --git a/ui/platform_window/agl/platform_window_agl.h b/ui/platform_window/agl/platform_window_agl.h
new file mode 100644
index 0000000000000..4bc915d663e72
--- /dev/null
+++ b/ui/platform_window/agl/platform_window_agl.h
@@ -0,0 +1,36 @@
+// Copyright 2021 LG Electronics, Inc.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+//
+// SPDX-License-Identifier: Apache-2.0
+
+#ifndef UI_PLATFORM_WINDOW_AGL_PLATFORM_WINDOW_AGL_H_
+#define UI_PLATFORM_WINDOW_AGL_PLATFORM_WINDOW_AGL_H_
+
+#include <string>
+
+namespace ui {
+
+// AGL additions for platform window.
+class PlatformWindowAgl {
+ public:
+  virtual void SetAglActivateApp(const std::string& app) {}
+  virtual void SetAglAppId(const std::string& title) {}
+  virtual void SetAglReady() {}
+  virtual void SetAglBackground() {}
+  virtual void SetAglPanel(uint32_t edge) {}
+};
+
+}  // namespace ui
+
+#endif  // UI_PLATFORM_WINDOW_AGL_PLATFORM_WINDOW_AGL_H_
diff --git a/ui/platform_window/platform_window.h b/ui/platform_window/platform_window.h
index a7bd3ef17a728..80f67671b88cf 100644
--- a/ui/platform_window/platform_window.h
+++ b/ui/platform_window/platform_window.h
@@ -9,6 +9,7 @@
 #include <string>
 #include <vector>
 
+#include "agl/platform_window_agl.h"
 #include "base/component_export.h"
 #include "ui/base/class_property.h"
 #include "ui/base/ui_base_types.h"
@@ -32,7 +33,8 @@ class PlatformCursor;
 
 // Generic PlatformWindow interface.
 class COMPONENT_EXPORT(PLATFORM_WINDOW) PlatformWindow
-    : public PropertyHandler {
+    : public PropertyHandler,
+      public PlatformWindowAgl {
  public:
   PlatformWindow();
   ~PlatformWindow() override;
-- 
2.37.2

